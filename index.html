<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Turn-by-Turn Navigation (Google Maps)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;padding:0;overflow:hidden}
    #map{height:100vh;width:100vw}
    #top-controls{
      position:absolute;z-index:10005;left:10px;top:10px; /* raised z-index so controls sit above map panes */
      background:#fff;border-radius:8px;box-shadow:0 0 10px #00000030;
      padding:10px;font-size:1rem;display:flex;flex-direction:column;gap:8px;
      max-width:400px;
    }
    select,button{font-size:1rem;padding:10px;border-radius:6px;border:1px solid #aaa}
    button{background:#007bff;color:#fff;font-weight:700;cursor:pointer;border:none;box-shadow:0 2px 8px #00000020}
    button:disabled{background:#b0b0b0;cursor:not-allowed}
    @media (max-width:600px){#top-controls{max-width:95vw}}

    /* Force-hide common floating Google panels that appear on the map (BUT do NOT hide our #directions-panel) */
    /* Keep this narrow so the directions panel we attach remains visible */
    .adp, .adp-panel, .gm-style .adp, .gm-style .adp-panel {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* directions panel inside controls */
    #directions-panel {
      display: none;               /* shown when a route is available */
      max-height: 40vh;
      overflow: auto;
      padding: 6px;
      border-top: 1px solid #ddd;
      font-size: 0.9rem;
      background: #fff;
      margin-top: 8px;
      border-radius: 6px;
    }
  </style>

  <!-- Replace YOUR_API_KEY with your Google Maps API key -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA2L3tqB0y8yQMCzHSKxXQSZ1O3A3EMeko&libraries=places,geometry&callback=initMap">
  </script>
</head>
<body>
  <div id="top-controls">
    <select id="building-select">
      <option disabled selected value="">Select a Destination</option>
      <option value="9.649295884532481,123.86859277164733">Bates Building</option>
      <option value="9.648274323006579,123.867375894612">Elementary Building</option>
      <option value="9.649258920201365,123.86913815071111">Senior High School Building</option>
      <option value="9.6501393425521,123.86784628406689">College of Art Sciences Building</option>
      <option value="9.648836069141659,123.8671386907348">Junior High School Building</option>
      <option value="9.6521302,123.8691414">Barder Gym</option>
    </select>
    <button id="start-nav-btn" disabled>START NAVIGATING</button>

    <!-- panel that will receive turn-by-turn text from DirectionsRenderer -->
    <div id="directions-panel" aria-hidden="true"></div>
  </div>

  <div id="map"></div>

  <script>
    let map;
    let userMarker = null;
    let destMarker = null;
    let directionsService = null;
    let directionsRenderer = null;
    let watchId = null;
    let lastUpdate = 0;
    let lastRouteTime = 0;
    let lastRouteOrigin = null;
    let currentDest = null;
    let currentDestName = null;

    // control timings
    const watchThrottleMs = 1000;
    const rerouteThrottleMs = 4000;
    const rerouteMoveThresholdM = 8;

    const autoFollow = true;
    let schoolPolygon = null;
    const MAX_ROUTE_RETRIES = 3;

    const SCHOOL_BOUNDARY_COORDS = [
      { lat: 9.6492779, lng: 123.8670981 },
      { lat: 9.6484880, lng: 123.8662200 },
      { lat: 9.6477290, lng: 123.8677810 },
      { lat: 9.6484410, lng: 123.8690630 },
      { lat: 9.6490790, lng: 123.8666210 },
      { lat: 9.6491020, lng: 123.8696240 },
      { lat: 9.6495210, lng: 123.8666880 },
      { lat: 9.6504230, lng: 123.8667810 },
      { lat: 9.6497110, lng: 123.8697430 },
      { lat: 9.6513950, lng: 123.8666670 },
      { lat: 9.6506750, lng: 123.8693480 },
      { lat: 9.6520680, lng: 123.8680240 },
      { lat: 9.6521310, lng: 123.8698930 },
      { lat: 9.6532100, lng: 123.8695520 },
      { lat: 9.6532310, lng: 123.8700030 }
    ];

    // compute convex hull (Monotone chain) over points (treat x=lng, y=lat)
    function computeConvexHull(points) {
      if (!points || points.length < 3) return points.slice();
      // map to [lng, lat] pairs and sort
      const pts = points.map(p => ({ x: p.lng, y: p.lat, orig: p }))
                         .sort((a,b) => a.x === b.x ? a.y - b.y : a.x - b.x);

      const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

      const lower = [];
      for (let p of pts) {
        while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) {
          lower.pop();
        }
        lower.push(p);
      }

      const upper = [];
      for (let i = pts.length - 1; i >= 0; i--) {
        const p = pts[i];
        while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) {
          upper.pop();
        }
        upper.push(p);
      }

      // Concatenate lower and upper to get full hull; remove duplicate end points
      upper.pop();
      lower.pop();
      const hull = lower.concat(upper).map(p => ({ lat: p.y, lng: p.x }));
      return hull;
    }

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 9.649, lng: 123.868 },
        zoom: 17,
        disableDefaultUI: true
      });

      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({
        suppressMarkers: true,
        panel: null, // will attach below
        polylineOptions: { strokeColor: '#1976D2', strokeWeight: 6, strokeOpacity: 0.95 }
      });

      // defensive: ensure no panel is attached and hide any injected panel
      directionsRenderer.setPanel(null);
      directionsRenderer.setMap(map);

      // Attach the visible directions panel so turn-by-turn text appears
      const dirPanel = document.getElementById('directions-panel');
      if (dirPanel) {
        directionsRenderer.setPanel(dirPanel);
      }

      // no static markers â€” we'll show only the selected destination marker

      // remove injected floating panels if any (we still remove known floating classes)
      setTimeout(() => {
        const candidates = document.querySelectorAll('.adp, .adp-panel, .gmnoprint[dir]');
        candidates.forEach(el => el.remove());
      }, 500);

      // apply school boundary and restrictions
      applySchoolBoundary(SCHOOL_BOUNDARY_COORDS);
    }

    // apply polygon, restriction and minZoom
    function applySchoolBoundary(coords) {
      if (!coords || coords.length < 3) {
        console.error('School boundary requires at least 3 coordinates.');
        return;
      }

      // build outer circumference using convex hull so points are not arbitrarily connected
      const hullCoords = computeConvexHull(coords);
      const path = hullCoords.map(c => new google.maps.LatLng(c.lat, c.lng));
      const bounds = new google.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));

      if (schoolPolygon) schoolPolygon.setMap(null);

      schoolPolygon = new google.maps.Polygon({
        paths: path,
        strokeColor: '#FF0000',
        strokeOpacity: 1,
        strokeWeight: 4,
        // no fill so area inside circumference is not colored
        fillOpacity: 0,
        clickable: false
      });
      schoolPolygon.setMap(map);

      // restrict map to polygon bounds (strict)
      map.setOptions({
        restriction: {
          latLngBounds: bounds,
          strictBounds: true
        }
      });

      // fit and then lock minZoom to prevent zooming out beyond the visual boundary
      map.fitBounds(bounds);
      google.maps.event.addListenerOnce(map, 'idle', () => {
        const fitZoom = map.getZoom();
        if (typeof fitZoom === 'number') {
          map.setOptions({ minZoom: fitZoom });
        }
      });
    }

    // check whether a DirectionsResult stays inside the polygon
    function routeIsInsidePolygon(result) {
      if (!schoolPolygon || !result || !result.routes || result.routes.length === 0) return false;
      const overview = result.routes[0].overview_path || [];
      for (let i = 0; i < overview.length; i++) {
        if (!google.maps.geometry.poly.containsLocation(overview[i], schoolPolygon)) {
          return false;
        }
      }
      return true;
    }

    // simple centroid computation to pick an interior waypoint (usually inside for convex-ish shapes)
    function computeCentroid(coords) {
      let x = 0, y = 0, z = 0;
      coords.forEach(c => {
        const lat = c.lat * Math.PI / 180;
        const lng = c.lng * Math.PI / 180;
        x += Math.cos(lat) * Math.cos(lng);
        y += Math.cos(lat) * Math.sin(lng);
        z += Math.sin(lat);
      });
      const total = coords.length;
      x /= total; y /= total; z /= total;
      const centralLng = Math.atan2(y, x);
      const hyp = Math.sqrt(x * x + y * y);
      const centralLat = Math.atan2(z, hyp);
      return { lat: centralLat * 180 / Math.PI, lng: centralLng * 180 / Math.PI };
    }

    // request route with retry using an interior waypoint (centroid) if route goes outside polygon
    function requestRouteWithRetries(origin, destination, requiredWaypoints = [], attempt = 0) {
      const req = {
        origin,
        destination,
        travelMode: google.maps.TravelMode.WALKING,
        optimizeWaypoints: false
      };

      // include required waypoints (forced path) in order, if any
      if (requiredWaypoints && requiredWaypoints.length > 0) {
        req.waypoints = requiredWaypoints.map(wp => ({ location: wp, stopover: false }));
      } else {
        req.waypoints = [];
      }

      // if this is a retry, append the centroid as an additional non-stopover waypoint
      if (attempt > 0) {
        const centroid = computeCentroid(SCHOOL_BOUNDARY_COORDS);
        req.waypoints.push({ location: centroid, stopover: false });
      }

      directionsService.route(req, (result, status) => {
        if (status === 'OK' && result) {
          if (routeIsInsidePolygon(result) || attempt >= MAX_ROUTE_RETRIES) {
            // accept this route
            directionsRenderer.setDirections(result);

            // show directions panel when we have a route
            const dp = document.getElementById('directions-panel');
            if (dp) dp.style.display = 'block';

            lastRouteTime = Date.now();
            lastRouteOrigin = origin;
            updateUserMarker(origin);
            updateDestMarker(destination, document.getElementById('building-select').selectedOptions[0]?.text || '');
            if (!routeIsInsidePolygon(result)) {
              console.warn('Route goes outside boundary and retry limit reached; showing best available route.');
            }
          } else {
            // route goes outside polygon -> retry with a waypoint inside
            if (attempt + 1 <= MAX_ROUTE_RETRIES) {
              requestRouteWithRetries(origin, destination, requiredWaypoints, attempt + 1);
            } else {
              // final fallback: display route anyway
              directionsRenderer.setDirections(result);
              const dp2 = document.getElementById('directions-panel');
              if (dp2) dp2.style.display = 'block';
            }
          }
        } else {
          console.error('Directions error:', status);
        }
      });
    }

    // tolerance settings (meters)
    const WAYPOINT_COVER_TOL_M = 20;    // route point within 20m counts as covering a waypoint
    const WAYPOINT_FORCE_DIST_M = 50;   // origin/destination within 50m of any waypoint -> force waypoints

    // returns true if the route's overview_path comes within tol meters of every required waypoint
    function routeCoversWaypoints(result, requiredWaypoints, tol = WAYPOINT_COVER_TOL_M) {
      // ...existing defensive guards...
      if (!result || !result.routes || result.routes.length === 0) return false;
      if (!requiredWaypoints || requiredWaypoints.length === 0) return true;
      const overview = result.routes[0].overview_path || [];
      if (!overview || overview.length === 0) return false;

      for (let wi = 0; wi < requiredWaypoints.length; wi++) {
        const wp = requiredWaypoints[wi];
        const wpLatLng = new google.maps.LatLng(wp.lat, wp.lng);
        let hit = false;
        for (let i = 0; i < overview.length; i++) {
          const d = google.maps.geometry.spherical.computeDistanceBetween(wpLatLng, overview[i]);
          if (d <= tol) { hit = true; break; }
        }
        if (!hit) return false;
      }
      return true;
    }

    // compute minimum distance (meters) from a point to the list of waypoints
    function minDistanceToWaypoints(point, requiredWaypoints) {
      if (!requiredWaypoints || requiredWaypoints.length === 0) return Infinity;
      const p = new google.maps.LatLng(point.lat, point.lng);
      let minD = Infinity;
      for (const wp of requiredWaypoints) {
        const w = new google.maps.LatLng(wp.lat, wp.lng);
        const d = google.maps.geometry.spherical.computeDistanceBetween(p, w);
        if (d < minD) minD = d;
      }
      return minD;
    }

    // Smart requester: try without forced waypoints first, decide whether to force them
    function smartRequestRoute(origin, destination, requiredWaypoints = []) {
      const testReq = {
        origin,
        destination,
        travelMode: google.maps.TravelMode.WALKING,
        optimizeWaypoints: false,
        waypoints: [] // explicitly none for test
      };

      directionsService.route(testReq, (result, status) => {
        if (status === 'OK' && result) {
          if (requiredWaypoints && requiredWaypoints.length > 0 && routeCoversWaypoints(result, requiredWaypoints)) {
            directionsRenderer.setDirections(result);
            lastRouteTime = Date.now();
            lastRouteOrigin = origin;
            updateUserMarker(origin);
            updateDestMarker(destination, document.getElementById('building-select').selectedOptions[0]?.text || '');
            return;
          }

          // If required waypoints are relevant (Elementary/Junior High), decide whether to force them.
          if (requiredWaypoints && requiredWaypoints.length > 0) {
            // If user (origin) or destination is very near any required waypoint, force waypoints
            const dOrigin = minDistanceToWaypoints(origin, requiredWaypoints);
            const dDest = minDistanceToWaypoints(destination, requiredWaypoints);
            if (Math.min(dOrigin, dDest) <= WAYPOINT_FORCE_DIST_M) {
              // force waypoints (use existing retry/centroid logic)
              requestRouteWithRetries(origin, destination, requiredWaypoints, 0);
              return;
            }
          }

          // Otherwise accept the unconstrained route (but still ensure polygon containment via retries)
          // Use requestRouteWithRetries but with empty requiredWaypoints so centroid retry remains available.
          requestRouteWithRetries(origin, destination, [], 0);
        } else {
          requestRouteWithRetries(origin, destination, requiredWaypoints, 0);
        }
      });
    }

    // replace simple createRoute with smartRequestRoute usage
    function createRoute(origin, destination, requiredWaypoints = []) {
      // prefer smart logic that only forces waypoints when necessary
      smartRequestRoute(origin, destination, requiredWaypoints);
    }

    const selectEl = document.getElementById('building-select');
    const startBtn = document.getElementById('start-nav-btn');

    // Safety: ensure controls are on top
    document.getElementById('top-controls').style.zIndex = 10005;

    // Ensure Start is enabled on input/change
    selectEl.addEventListener('input', () => {
      if (selectEl.value) startBtn.disabled = false;
    });

    // keep the change handler that sets currentDest/currentDestName
    selectEl.addEventListener('change', () => {
      if (!selectEl.value) return;
      currentDest = (function(csv){ const [lat,lng]=csv.split(',').map(Number); return {lat,lng}; })(selectEl.value);
      currentDestName = selectEl.selectedOptions[0].text;
      updateDestMarker(currentDest, currentDestName);
      startBtn.disabled = false;
      map.setCenter(currentDest);
      map.setZoom(17);
    });

    // Single, reliable start handler
    function startNavigation() {
      if (!currentDest) {
        console.warn('No destination selected');
        startBtn.disabled = true;
        return;
      }

      // clear any existing watch
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }

      if (!navigator.geolocation) {
        console.error('Geolocation not supported');
        return;
      }

      // initial position + route
      navigator.geolocation.getCurrentPosition(pos => {
        const userPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        updateUserMarker(userPos);
        fitBoundsBetween(userPos, currentDest);
        // pass any required waypoints for the selected destination (if configured)
        createRoute(userPos, currentDest, REQUIRED_WAYPOINTS[currentDestName] || []);
      }, err => {
        console.error('Location denied/unavailable', err);
      }, { enableHighAccuracy: true, maximumAge: 0, timeout: 12000 });

      // watch and follow user; reroute only when needed
      watchId = navigator.geolocation.watchPosition(pos => {
        const now = Date.now();
        if (now - lastUpdate < watchThrottleMs) return;
        lastUpdate = now;

        const userPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        updateUserMarker(userPos);

        if (autoFollow) {
          map.panTo(userPos);
        } else {
          fitBoundsBetween(userPos, currentDest);
        }

        const needReroute = !lastRouteOrigin ||
                            (getDistanceMeters(userPos, lastRouteOrigin) > rerouteMoveThresholdM) ||
                            (now - lastRouteTime > rerouteThrottleMs * 3);

        if (needReroute && (now - lastRouteTime > rerouteThrottleMs)) {
          createRoute(userPos, currentDest, REQUIRED_WAYPOINTS[currentDestName] || []);
        }
      }, err => {
        console.error('Watch position failed', err);
      }, { enableHighAccuracy: true, maximumAge: 0, timeout: 12000 });
    }

    // Attach single click listener
    startBtn.addEventListener('click', (e) => {
      if (startBtn.disabled) { e.preventDefault(); console.warn('Start clicked but disabled'); return; }
      startBtn.blur();
      startNavigation();
    });

    window.addEventListener('beforeunload', () => {
      if (watchId !== null) navigator.geolocation.clearWatch(watchId);
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Turn-by-Turn Navigation (Google Maps)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;padding:0;overflow:hidden}
    #map{height:100vh;width:100vw}
    #top-controls{
      position:absolute;z-index:10005;left:10px;top:10px; /* raised z-index so controls sit above map panes */
      background:#fff;border-radius:8px;box-shadow:0 0 10px #00000030;
      padding:10px;font-size:1rem;display:flex;flex-direction:column;gap:8px;
      max-width:400px;
    }
    select,button{font-size:1rem;padding:10px;border-radius:6px;border:1px solid #aaa}
    button{background:#007bff;color:#fff;font-weight:700;cursor:pointer;border:none;box-shadow:0 2px 8px #00000020}
    button:disabled{background:#b0b0b0;cursor:not-allowed}
    @media (max-width:600px){#top-controls{max-width:95vw}}

    /* Force-hide any Google directions floating panel injected into the map
       NOTE: do NOT hide our #directions-panel (text panel inside controls) */
    .adp, .adp-panel, .gm-style .adp, .gm-style .adp-panel, .gmnoprint[dir] {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    /* directions panel inside controls */
    #directions-panel {
      display: none;               /* shown when a route is available */
      max-height: 40vh;
      overflow: auto;
      padding: 6px;
      border-top: 1px solid #ddd;
      font-size: 0.9rem;
      background: #fff;
      margin-top: 8px;
      border-radius: 6px;
    }
  </style>

  <!-- Replace YOUR_API_KEY with your Google Maps API key -->
  <script async defer
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA2L3tqB0y8yQMCzHSKxXQSZ1O3A3EMeko&libraries=places,geometry&callback=initMap">
  </script>
</head>
<body>
  <div id="top-controls">
    <select id="building-select">
      <option disabled selected value="">Select a Destination</option>
      <option value="9.649295884532481,123.86859277164733">Bates Building</option>
      <option value="9.648274323006579,123.867375894612">Elementary Building</option>
      <option value="9.649258920201365,123.86913815071111">Senior High School Building</option>
      <option value="9.648836069141659,123.8671386907348">Junior High School Building</option>
      <option value="9.6521302,123.8691414">Barder Gym</option>
      <option value="9.6490669,123.8667098">HNU Covered Court</option>
      <option value="9.6486446,123.8674724">HNU Bookstore</option>
      <option value="9.6486446,123.8674724">Janssen Food Court</option>
      <option value="9.6495419,123.8671432">HNU Church</option>
      <option value="9.6493437,123.8678556">HNU Old Gym</option>
      <option value="9.649857,123.867966">Scanlon Building</option>
      <option value="9.650429,123.867758">Freinademetz Building</option>
      <option value="9.6504749,123.8684188">HNU SVD Residence</option>
    </select>
    <button id="start-nav-btn" disabled>START NAVIGATING</button>

    <!-- panel that will receive turn-by-turn text from DirectionsRenderer -->
    <div id="directions-panel" aria-hidden="true"></div>
  </div>

  <div id="map"></div>

  <script>
    let map;
    let userMarker = null;
    let destMarker = null;
    let directionsService = null;
    let directionsRenderer = null;
    let watchId = null;
    let lastUpdate = 0;
    let lastRouteTime = 0;
    let lastRouteOrigin = null;
    let currentDest = null;
    let currentDestName = null;

    // control timings â€” tuned for aggressive follow (reroute when user moves ~1m)
    // watchThrottleMs: marker/map update frequency (ms)
    // rerouteThrottleMs: minimum time between direction requests (ms)
    // rerouteMoveThresholdM: distance (meters) user must move to trigger reroute
    const watchThrottleMs = 300;       // update marker/map up to ~3x per second
    const rerouteThrottleMs = 1000;    // allow reroutes at most once per second
    const rerouteMoveThresholdM = 1;   // request new route when moved more than ~1 meter

    const autoFollow = true;
    let schoolPolygon = null;
    const MAX_ROUTE_RETRIES = 3;

    // Only force required waypoint sequences when origin or destination
    // is reasonably near the waypoint set (meters).
    const WAYPOINT_FORCE_DIST_M = 50;

    // compute minimum distance (meters) from a point to the list of waypoints
    function minDistanceToWaypoints(point, requiredWaypoints) {
      if (!requiredWaypoints || requiredWaypoints.length === 0) return Infinity;
      let minD = Infinity;
      for (const wp of requiredWaypoints) {
        const d = getDistanceMeters(point, wp);
        if (d < minD) minD = d;
      }
      return minD;
    }

    // Recommend using required waypoints only if origin or destination is near them
    function shouldUseRequiredWaypoints(origin, destination, requiredWaypoints) {
      if (!requiredWaypoints || requiredWaypoints.length === 0) return false;
      const dOrigin = minDistanceToWaypoints(origin, requiredWaypoints);
      const dDest = minDistanceToWaypoints(destination, requiredWaypoints);
      return Math.min(dOrigin, dDest) <= WAYPOINT_FORCE_DIST_M;
    }

    // REQUIRED WAYPOINTS: strict waypoint sequences for two destinations
    const REQUIRED_WAYPOINTS = {
      "Junior High School Building": [
        { lat: 9.649228, lng: 123.86768 },
        { lat: 9.649145, lng: 123.867732 },
        { lat: 9.649122, lng: 123.867732 },
        { lat: 9.649086, lng: 123.867674 },
        { lat: 9.649019, lng: 123.867558 },
        { lat: 9.648836, lng: 123.86738 },
        { lat: 9.648786, lng: 123.86736 }
      ],
      "Elementary Building": [
        { lat: 9.649228, lng: 123.86768 },
        { lat: 9.649145, lng: 123.867732 },
        { lat: 9.649122, lng: 123.867732 },
        { lat: 9.649086, lng: 123.867674 },
        { lat: 9.649019, lng: 123.867558 },
        { lat: 9.648836, lng: 123.86738 },
        { lat: 9.648786, lng: 123.86736 }
      ]
    };

    const SCHOOL_BOUNDARY_COORDS = [
      { lat: 9.6492779, lng: 123.8670981 },
      { lat: 9.6484880, lng: 123.8662200 },
      { lat: 9.6477290, lng: 123.8677810 },
      { lat: 9.6484410, lng: 123.8690630 },
      { lat: 9.6490790, lng: 123.8666210 },
      { lat: 9.6491020, lng: 123.8696240 },
      { lat: 9.6495210, lng: 123.8666880 },
      { lat: 9.6504230, lng: 123.8667810 },
      { lat: 9.6497110, lng: 123.8697430 },
      { lat: 9.6513950, lng: 123.8666670 },
      { lat: 9.6506750, lng: 123.8693480 },
      { lat: 9.6520680, lng: 123.8680240 },
      { lat: 9.6521310, lng: 123.8698930 },
      { lat: 9.6532100, lng: 123.8695520 },
      { lat: 9.6532310, lng: 123.8700030 }
    ];

    // compute convex hull (Monotone chain) over points (treat x=lng, y=lat)
    function computeConvexHull(points) {
      if (!points || points.length < 3) return points.slice();
      // map to [lng, lat] pairs and sort
      const pts = points.map(p => ({ x: p.lng, y: p.lat, orig: p }))
                         .sort((a,b) => a.x === b.x ? a.y - b.y : a.x - b.x);

      const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

      const lower = [];
      for (let p of pts) {
        while (lower.length >= 2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) {
          lower.pop();
        }
        lower.push(p);
      }

      const upper = [];
      for (let i = pts.length - 1; i >= 0; i--) {
        const p = pts[i];
        while (upper.length >= 2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) {
          upper.pop();
        }
        upper.push(p);
      }

      // Concatenate lower and upper to get full hull; remove duplicate end points
      upper.pop();
      lower.pop();
      const hull = lower.concat(upper).map(p => ({ lat: p.y, lng: p.x }));
      return hull;
    }

    // apply polygon, restriction and minZoom
    function applySchoolBoundary(coords) {
      if (!coords || coords.length < 3) {
        console.error('School boundary requires at least 3 coordinates.');
        return;
      }

      // build outer circumference using convex hull so points are not arbitrarily connected
      const hullCoords = computeConvexHull(coords);
      const path = hullCoords.map(c => new google.maps.LatLng(c.lat, c.lng));
      const bounds = new google.maps.LatLngBounds();
      path.forEach(p => bounds.extend(p));

      if (schoolPolygon) schoolPolygon.setMap(null);

      schoolPolygon = new google.maps.Polygon({
        paths: path,
        strokeColor: '#FF0000',
        strokeOpacity: 1,
        strokeWeight: 4,
        // no fill so area inside circumference is not colored
        fillOpacity: 0,
        clickable: false
      });
      schoolPolygon.setMap(map);

      // restrict map to polygon bounds (strict)
      map.setOptions({
        restriction: {
          latLngBounds: bounds,
          strictBounds: true
        }
      });

      // fit and then lock minZoom to prevent zooming out beyond the visual boundary
      map.fitBounds(bounds);
      google.maps.event.addListenerOnce(map, 'idle', () => {
        const fitZoom = map.getZoom();
        if (typeof fitZoom === 'number') {
          // allow one zoom level out from the fit so the map is less tightly zoomed
          const relaxed = Math.max(12, fitZoom - 1); // floor at 12 to avoid too-far zoom out
          map.setOptions({ minZoom: relaxed });
          // optionally set current zoom to the relaxed level so user sees the less-zoomed view immediately
          if (map.getZoom() > relaxed) map.setZoom(relaxed);
        }
      });
    }

    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 9.649, lng: 123.868 },
        zoom: 15, // lowered default zoom so map starts less zoomed-in
        disableDefaultUI: true
      });

      directionsService = new google.maps.DirectionsService();
      directionsRenderer = new google.maps.DirectionsRenderer({
        suppressMarkers: true,
        polylineOptions: { strokeColor: '#1976D2', strokeWeight: 6, strokeOpacity: 0.95 }
      });
      directionsRenderer.setMap(map);
      // attach our on-page directions panel so textual steps appear
      const dirPanel = document.getElementById('directions-panel');
      if (dirPanel) directionsRenderer.setPanel(dirPanel);

      // apply school boundary and restrictions (keep boundary to lock view)
      applySchoolBoundary(SCHOOL_BOUNDARY_COORDS);
    }

    // SIMPLE ROUTE: single request, optionally include REQUIRED_WAYPOINTS for two destinations
    function createRoute(origin, destination, requiredWaypoints = []) {
      const req = {
        origin,
        destination,
        travelMode: google.maps.TravelMode.WALKING,
        optimizeWaypoints: false
      };
      if (requiredWaypoints && requiredWaypoints.length > 0) {
        req.waypoints = requiredWaypoints.map(wp => ({ location: wp, stopover: false }));
      }
      directionsService.route(req, (result, status) => {
        if (status === 'OK' && result) {
          directionsRenderer.setDirections(result);
          const dp = document.getElementById('directions-panel');
          if (dp) dp.style.display = 'block';
          lastRouteTime = Date.now();
          lastRouteOrigin = origin;
        } else {
          console.error('DirectionsService error:', status, result);
          alert('Unable to compute route: ' + status);
        }
      });
    }

    // Minimal helper functions used by navigation UI:
    function updateUserMarker(latlng) {
      if (userMarker) userMarker.setPosition(latlng);
      else {
        userMarker = new google.maps.Marker({
          position: latlng,
          map,
          title: 'You are here',
          icon: { path: google.maps.SymbolPath.CIRCLE, scale: 7, fillColor: '#1976D2', fillOpacity: 1, strokeWeight: 1 }
        });
      }
    }

    function fitBoundsBetween(a, b) {
      const bounds = new google.maps.LatLngBounds();
      bounds.extend(a);
      bounds.extend(b);
      map.fitBounds(bounds, 70);
    }

    function getDistanceMeters(a, b) {
      const toRad = v => v * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lng - a.lng);
      const lat1 = toRad(a.lat);
      const lat2 = toRad(b.lat);
      const sinDLat = Math.sin(dLat/2);
      const sinDLon = Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(sinDLat*sinDLat + Math.cos(lat1)*Math.cos(lat2)*sinDLon*sinDLon), Math.sqrt(1 - (sinDLat*sinDLat + Math.cos(lat1)*Math.cos(lat2)*sinDLon*sinDLon)));
      return R * c;
    }

    // show only selected destination marker (red pushpin)
    function updateDestMarker(latlng, label) {
      // clear any previous directions text
      const dp = document.getElementById('directions-panel');
      if (dp) { dp.style.display = 'none'; dp.innerHTML = ''; }
      if (directionsRenderer) directionsRenderer.set('directions', null);
      if (destMarker) destMarker.setMap(null);
      destMarker = new google.maps.Marker({
        position: latlng,
        map,
        title: label,
        icon: { url: "http://maps.google.com/mapfiles/ms/icons/red-pushpin.png" }
      });
    }

    const selectEl = document.getElementById('building-select');
    const startBtn = document.getElementById('start-nav-btn');

    // Safety: ensure controls are on top
    document.getElementById('top-controls').style.zIndex = 10005;

    // Ensure Start is enabled on input/change
    selectEl.addEventListener('input', () => {
      if (selectEl.value) startBtn.disabled = false;
    });

    // keep the change handler that sets currentDest/currentDestName
    selectEl.addEventListener('change', () => {
      if (!selectEl.value) return;
      // hide/clear previous directions when selecting a new destination
      const dp = document.getElementById('directions-panel');
      if (dp) { dp.style.display = 'none'; dp.innerHTML = ''; }
      if (directionsRenderer) directionsRenderer.set('directions', null);

      currentDest = (function(csv){ const [lat,lng]=csv.split(',').map(Number); return {lat,lng}; })(selectEl.value);
      currentDestName = selectEl.selectedOptions[0].text;
      updateDestMarker(currentDest, currentDestName);
      startBtn.disabled = false;
      map.setCenter(currentDest);
      map.setZoom(15); // use a lower zoom when focusing the chosen destination
    });

    // Single, reliable start handler
    function startNavigation() {
      if (!currentDest) {
        console.warn('No destination selected');
        startBtn.disabled = true;
        return;
      }

      // clear any existing watch
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }

      if (!navigator.geolocation) {
        console.error('Geolocation not supported');
        return;
      }

      // initial position + route
      navigator.geolocation.getCurrentPosition(pos => {
        const userPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        updateUserMarker(userPos);
        fitBoundsBetween(userPos, currentDest);
        // only include required waypoints when the user is near them (recommended)
        const reqWps = REQUIRED_WAYPOINTS[currentDestName] || [];
        const useReq = shouldUseRequiredWaypoints(userPos, currentDest, reqWps);
        createRoute(userPos, currentDest, useReq ? reqWps : []);
      }, err => {
        console.error('Location denied/unavailable', err);
      }, { enableHighAccuracy: true, maximumAge: 0, timeout: 12000 });

      // watch and follow user; reroute only when needed
      watchId = navigator.geolocation.watchPosition(pos => {
        const now = Date.now();
        if (now - lastUpdate < watchThrottleMs) return;
        lastUpdate = now;

        const userPos = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        updateUserMarker(userPos);

        if (autoFollow) {
          map.panTo(userPos);
        } else {
          fitBoundsBetween(userPos, currentDest);
        }

        const needReroute = !lastRouteOrigin ||
                            (getDistanceMeters(userPos, lastRouteOrigin) > rerouteMoveThresholdM) ||
                            (now - lastRouteTime > rerouteThrottleMs * 3);

        if (needReroute && (now - lastRouteTime > rerouteThrottleMs)) {
          const reqWpsWatch = REQUIRED_WAYPOINTS[currentDestName] || [];
          const useReqWatch = shouldUseRequiredWaypoints(userPos, currentDest, reqWpsWatch);
          createRoute(userPos, currentDest, useReqWatch ? reqWpsWatch : []);
        }
      }, err => {
        console.error('Watch position failed', err);
      }, { enableHighAccuracy: true, maximumAge: 0, timeout: 12000 });
    }

    // Attach single click listener
    startBtn.addEventListener('click', (e) => {
      if (startBtn.disabled) { e.preventDefault(); console.warn('Start clicked but disabled'); return; }
      startBtn.blur();
      startNavigation();
    });

    window.addEventListener('beforeunload', () => {
      if (watchId !== null) navigator.geolocation.clearWatch(watchId);
    });
  </script>
</body>
</html>
